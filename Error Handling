1. Centralised Error Handling Middleware
Step 1- Create Error Handling Middleware
// src/middlewares/errorHandler.js
const errorHandler = (err, req, res, next) => {
  console.error(err); // Log the error for debugging purposes

  // Handle validation errors
  if (err.name === 'ValidationError') {
    return res.status(400).json({ message: err.message });
  }

  // Handle duplicate key errors (e.g., email already exists)
  if (err.code === 11000) {
    return res.status(400).json({ message: 'Email already exists' });
  }

  // Handle JWT errors
  if (err.name === 'JsonWebTokenError') {
    return res.status(401).json({ message: 'Invalid token' });
  }

  if (err.name === 'TokenExpiredError') {
    return res.status(401).json({ message: 'Token expired' });
  } 
  // Default error response for unexpected errors
  return res.status(500).json({ message: 'Internal server error' });
};

module.exports = errorHandler; 

Step 2: Use the Error Handling Middleware
// src/app.js
const express = require('express');
const mongoose = require('mongoose');
const userRoutes = require('./routes/userRoutes');
const expenseRoutes = require('./routes/expenseRoutes');
const errorHandler = require('./middlewares/errorHandler');

const app = express();

app.use(express.json());
app.use('/api', userRoutes);
app.use('/api', expenseRoutes);

// Error handling middleware
app.use(errorHandler);

const start = async () => {
  try {
    await mongoose.connect('your_mongodb_uri', { useNewUrlParser: true, useUnifiedTopology: true });
    app.listen(3000, () => console.log('Server running on port 3000'));
  } catch (error) {
    console.error('Error connecting to the database', error);
  }
};

start();

2. Error Handling in Controllers
// src/controllers/UserController.js
const User = require('../models/User');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

exports.registerUser = async (req, res, next) => {
  const { email, name, mobile, password } = req.body;
  
  try {
    const hashedPassword = await bcrypt.hash(password, 10);
    const newUser = await User.create({ email, name, mobile, password: hashedPassword });
    res.status(201).json({ message: 'User registered successfully', userId: newUser._id });
  } catch (error) {
    next(error); // Pass errors to the error handler
  }
};

exports.loginUser = async (req, res, next) => {
  const { email, password } = req.body;
  
  try {
    const user = await User.findOne({ email });
    if (!user || !(await bcrypt.compare(password, user.password))) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }

    const token = jwt.sign({ userId: user._id }, 'your_jwt_secret', { expiresIn: '1h' });
    res.json({ token });
  } catch (error) {
    next(error); // Pass errors to the error handler
  }
};

3. Testing Error Handling
// tests/user.test.js
const request = require('supertest');
const app = require('../src/app');
const User = require('../src/models/User');

describe('User Authentication', () => {
  beforeAll(async () => {
    await User.deleteMany({});
  });

  it('should return an error for duplicate email', async () => {
    await request(app)
      .post('/api/users/register')
      .send({
        email: 'test@example.com',
        name: 'Test User',
        mobile: '1234567890',
        password: 'password123'
      });

    const res = await request(app)
      .post('/api/users/register')
      .send({
        email: 'test@example.com',
        name: 'Another User',
        mobile: '0987654321',
        password: 'password123'
      });
    expect(res.statusCode).toEqual(400);
    expect(res.body.message).toBe('Email already exists');
  });

  it('should return error for invalid login', async () => {
    const res = await request(app)
      .post('/api/users/login')
      .send({
        email: 'nonexistent@example.com',
        password: 'wrongpassword'
      });
    expect(res.statusCode).toEqual(401);
    expect(res.body.message).toBe('Invalid credentials');
  });
});
